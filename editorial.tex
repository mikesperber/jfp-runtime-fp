\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Special Issue on Run-Time Systems and Target Platforms for Functional Languages]
      {Special Issue on Run-Time Systems and Target Platforms for Functional Languages \\
Editorial}

{ \author{}}

\jdate{}
\pubyear{}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{}

\begin{document}
\maketitle

\noindent Most papers on functional programming are about its use or the design
of functional languages.  This special issue of JFP instead focusses
on low-level aspects of the \emph{implementation} of functional
languages~-- what happens during the run time of a functional program.
We volunteered to compile this special issue in 2012 and immediately
started soliciting papers.  The
original call for papers covered native-code platforms as well as
run-time systems originally conceived for non-functional languages
such as the Java Virtual Machine or the .NET Common Language Runtime.
Alas, most of our submissions focused on 
native-code run-time systems.  

The four accepted papers do
cover a wide spectrum of languages and implementation issues.  They
hint at the breadth of existing functional-language run-time systems
and the maturity of available implementations.  We hope that you enjoy
reading the papers as much as we did.

In \textit{MultiMLton: A Multicore-Aware Runtime for Standard ML},
Sivaramakrishnan, Ziarek and Jagannathan offer a comprehensive account
of a scalable multicore run-time system for an extended version of
Standard ML.  The MultiMLton system contains ACML, a version of
Concurrent ML extended with asynchronous events.  ACML allows the
programmer to express concurrency and exploit parallelism in a
program.  To implement the concurrency in an ACML program 
efficiently, the MultiMLton run-time system must provide
concurrency cheaper than the lightweight threads afforded through
efficient representations of continuations, a common strategy in
functional-language run-time systems.  To that end, MultiMLton provides
\textit{parasites}, which run conceptually asynchronous computations
on ``host threads,'' without allocating new threads.  Moreover, the
MultiMLton garbage collector implements thread-local heaps, and the
run-time system minimizes coordination between these heaps.

In \textit{A Run-Time Representation of Scheme Record Types}, Keep and
Dybvig provide an in-depth description of the run-time representation
of records in the Chez Scheme system.  Records as standardized in the
R6RS standard for Scheme are quite flexible, with run-time creation of
record types, flexible generativity, single inheritance, modular
constructors, and other features. Chez Scheme extends the R6RS record
system with additional facilities for implementing object-oriented programming
and foreign fields.  The run-time representation for these record types and
records poses many small but non-trivial challenges. Keep and Dybvig's paper
provides a complete tour with all the information an implementor might
need to replicate or improve upon their design for Chez Scheme.

In \textit{PAEAN: Portable Runtime Support for Physically-Shared-Nothing Architectures in Parallel Haskell Dialects},
Berthold, Loidl, and Hammond show how a high-level portable runtime system, PAEAN, provides
support for a parallel Haskell.
PAEAN abstracts of issues such as work distribution and distribution to be able
to handle different kinds of modern shared-nothing machines.
The system is built on top of the existing runtime system for the GHC Haskell compiler
which handles issues within a local machine, whereas PAEAN handles inter-machine
issues like task off-loading, load balancing, distributed garbage collection, etc.

In \textit{OCaml-Java: the Java Virtual Machine as the target of an OCaml compiler},
Xavier Clerc describes the OCaml-Java compiler and runtime system.
It translates regular OCaml source code into JVM bytecode, which enables
OCaml to use multuple cores and access Java libraries.
Since the Java bytecode and memory allocator was designed for an object oriented
language it is challanging to get good performance.
The paper describes the changes to the original OCaml compiler that had to be
made for OCaml-Java.  The paper also gives benchmarks comparing to Java and Scala.

We thank the authors and referees of these articles for their efforts
producing and reviewing these articles.  We also gratefully
acknowledge the support of Matthias Felleisen, David Tranah from the
editorial office of Cambridge University Press, and the JFP editorial
office.

\begin{flushright}
 Michael Sperber\\
  Active Group GmbH\\
  sperber@deinprogramm.de\\[2mm]
  Lennart Augustsson\\
  Standard Chartered Bank\\
  lennart@augustsson.net
\end{flushright}
\end{document}

% end of JFP2egui.tex
