\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Special Issue on Run-Time Systems and Target Platforms for Functional Languages]
      {Special Issue on Run-Time Systems and Target Platforms for Functional Languages \\
Editorial}

{ \author{}}

\jdate{}
\pubyear{}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{}

\begin{document}
\maketitle

\noindent Most papers on functional programming are about its use or the design
of functional languages.  This special issue of JFP instead focusses
on low-level aspects of the \emph{implementation} of functional
languages~-- what happens during the run time of a functional program.
We volunteered to compile this special issue in 2012 and immediately
started soliciting papers.  The
original call for papers covered native-code platforms as well as
run-time systems originally conceived for non-functional languages
such as the Java Virtual Machine or the .NET Common Language Runtime.
Alas, most of our submissions focused on 
native-code run-time systems.  

The papers we received
cover a wide spectrum of languages and implementation issues.  They
hint at the breadth of existing functional-language run-time systems
and the maturity of available implementations.  This issue of
\textit{Journal of Functional Programming} contains the first two
accepted papers; another issue will follow.
We hope that you enjoy
reading the papers as much as we did.

In \textit{MultiMLton: A Multicore-Aware Runtime for Standard ML},
Sivaramakrishnan, Ziarek and Jagannathan offer a comprehensive account
of a scalable multicore run-time system for an extended version of
Standard ML.  The MultiMLton system contains ACML, a version of
Concurrent ML extended with asynchronous events.  ACML allows the
programmer to express concurrency and exploit parallelism in a
program.  To implement the concurrency in an ACML program 
efficiently, the MultiMLton run-time system must provide
concurrency cheaper than the lightweight threads afforded through
efficient representations of continuations, a common strategy in
functional-language run-time systems.  To that end, MultiMLton provides
\textit{parasites}, which run conceptually asynchronous computations
on ``host threads,'' without allocating new threads.  Moreover, the
MultiMLton garbage collector implements thread-local heaps, and the
run-time system minimizes coordination between these heaps.

In \textit{A Run-Time Representation of Scheme Record Types}, Keep and
Dybvig provide an in-depth description of the run-time representation
of records in the Chez Scheme system.  Records as standardized in the
R6RS standard for Scheme are quite flexible, with run-time creation of
record types, flexible generativity, single inheritance, modular
constructors, and other features. Chez Scheme extends the R6RS record
system with additional facilities for implementing object-oriented programming
and foreign fields.  The run-time representation for these record types and
records poses many small but non-trivial challenges. Keep and Dybvig's paper
provides a complete tour with all the information an implementor might
need to replicate or improve upon their design for Chez Scheme.

We thank the authors and referees of these articles for their efforts
producing and reviewing these articles.  We also gratefully
acknowledge the support of Matthias Felleisen, David Tranah from the
editorial office of Cambridge University Press, and the JFP editorial
office.

\begin{flushright}
 Michael Sperber\\
  Active Group GmbH\\
  sperber@deinprogramm.de\\[2mm]
  Lennart Augustsson\\
  Standard Chartered Bank\\
  lennart@augustsson.net
\end{flushright}
\end{document}

% end of JFP2egui.tex
