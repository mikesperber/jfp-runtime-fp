\NeedsTeXFormat{LaTeX2e}

\documentclass{jfp1}

%%% Macros for the guide only %%%
\providecommand\AMSLaTeX{AMS\,\LaTeX}
\newcommand\eg{\emph{e.g.}\ }
\newcommand\etc{\emph{etc.}}
\newcommand\bcmdtab{\noindent\bgroup\tabcolsep=0pt%
  \begin{tabular}{@{}p{10pc}@{}p{20pc}@{}}}
\newcommand\ecmdtab{\end{tabular}\egroup}
\newcommand\rch[1]{$\longrightarrow\rlap{$#1$}$\hspace{1em}}
\newcommand\lra{\ensuremath{\quad\longrightarrow\quad}}

\title[Special Issue on Run-Time Systems and Target Platforms for Functional Languages]
      {Special Issue on Run-Time Systems and Target Platforms for Functional Languages \\
Editorial}

{ \author{}}

\jdate{}
\pubyear{}
\pagerange{\pageref{firstpage}--\pageref{lastpage}}
\doi{}

\begin{document}
\maketitle

\noindent Compiling functional languages to the existing variety of platforms tends to call 
for sophisticated implementations of run-time systems. This special issue focuses 
on this often-neglected aspect.  
We volunteered to compile this special issue in 2012 and immediately
started soliciting papers.  The
original call for papers covered native-code platforms as well as
run-time systems originally designed for non-functional languages
such as the Java Virtual Machine or the .NET Common Language Runtime.

The submissions covered a wide spectrum of languages and implementations,
with a focuse on native-code run-time systems.  This issue contains the
first two accepted papers.

In \textit{MultiMLton: A Multicore-Aware Runtime for Standard ML},
Sivaramakrishnan, Ziarek and Jagannathan offer a comprehensive account of a
scalable multicore run-time system for an extended version of Standard ML.
MultiMLton provides ACML, a variant of Concurrent ML with asynchronous
events, which allows programmers to elegantly express concurrency and
exploit parallelism.  To implement ACML's concurrency efficiently, the
MultiMLton run-time system provides extremely cheap concurrency.  To that
end, MultiMLton provides \textit{parasites}, which run conceptually
asynchronous computations on ``host threads,'' without allocating new
threads.  Moreover, the MultiMLton garbage collector implements
thread-local heaps, and the run-time system minimizes coordination between
these heaps.

In \textit{A Run-Time Representation of Scheme Record Types}, Keep and
Dybvig describes the run-time representation
of records in the Chez Scheme system.  
The R6RS standard for Scheme specifies records that allow run-time creation of
generative record types, single inheritance, and modular
constructors. Chez Scheme extends the R6RS record
system with additional facilities for implementing object-oriented programming
and foreign fields.  The run-time representation for these record types and
records poses many small but non-trivial challenges. Keep and Dybvig's paper
provides a complete tour with all the information an implementor might
need to replicate or improve upon their design for Chez Scheme.

We thank the authors and referees for their outstanding efforts.  We also gratefully
acknowledge the support of Matthias Felleisen, David Tranah, and the JFP editorial
office.  Finally, we hope that you enjoy
reading the papers as much as we did.


\begin{flushright}
 Michael Sperber\\
  Active Group GmbH\\
  sperber@deinprogramm.de\\[2mm]
  Lennart Augustsson\\
  Standard Chartered Bank\\
  lennart@augustsson.net
\end{flushright}
\end{document}

% end of JFP2egui.tex
